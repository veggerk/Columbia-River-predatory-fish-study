---
title: "walleye and northern pikeminnow mixing models with MixSIAR continuous size effect"
author: Karl Veggerby
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=FALSE, warning=FALSE,message=FALSE)

library(MixSIAR)
library(tidyverse)
library(stringi)
library(MCMCpack)
library(rlang)


```

Introduction 

**Note that the walleye model with size as a continuous effect failed to converge (see diagnostics in model output folder). Walleye size was classified as above 500mm and below 500mm and rerun in the "walleye_size_effect_by_group.Rmd" markdown doc.**


The goal is to run two stable isotope mixing models using the MixSIAR
package [version 3.1.12](https://cran.r-project.org/web/packages/MixSIAR/index.html)

Here we're only interested in how diet sources change in relation to season. Using smolt passage data, a before, during, and after migration value will be assigned to each fish based on capture date.


  We're going to split the data set into two groups: walleye and northern 
pikeminnow.

Each of two datasets will be modeled independently of one 
another in MixSIAR. We used the "MixSIAR GUI User Manual v3.1" [(available here)](https://github.com/brianstock/MixSIAR/)as a guide for running the models.

data summary
    
consumers  
  * **walleye**: n = 239
  * **northern pikeminnow**: n = 75
    
sources    
  * **walleye**: mixed non-salmonidae fish,
    mixed yearling salmonidae, mixed subyearling salmonidae, percopsidae
  * **northern pikeminnow**: mixed non-salmonidae,
    mixed yearling salmonidae, mixed subyearling salmonidae, percopsidae
    
trophic enrichment factor (data taken from Post 2002) 
  * **deltaC13**: 0.4, **standard deviation deltaC13**: 1.3
  * **deltaN15**: 1.3, **standard deviation deltaN15**: 1.0

Tissue turnover rate: we assumed the turnover rate for fin tissue was 62 days.Data from (Franssen et al. 2017). Therefore the percent of diet estimations can be assumed to be an average of approximately the past 2 months prior to capture.

priors (data taken from Poe et al. 1991)
  * We are using percent weight diet data from a feeding study for our priors.
  
 walleye Informative prior:

- American shad: 0.1%
- mixed non-Salmonid fish: 67.3%
- yearling Salmonid: 6.75%
- subyearling Salmonid: 6.75% 
    
   northern pikeminnow Informative prior:
   
- American shad: 0.3% 
- mixed non-Salmonid: 20.3%
- yearling Salmonid: 33.35%
- subyearling Salmonid: 33.35%


walleye: load data in
```{r walleye: load data in}


library(MixSIAR)

#load_mix_data
mix <- load_mix_data(filename=here("data", "clean_data", "walleye_mix_mixsiar.csv"),
iso_names=c("d15N","d13C"), factors=NULL,fac_random=NULL,
fac_nested=NULL, cont_effects="length_mm")

#load_source_data
source <- load_source_data(filename=here("data", "clean_data", "prey_data_walleye_avg.csv"),
source_factors=NULL, conc_dep=FALSE, data_type="means", mix)

#Load discrimination data
discr <- load_discr_data(filename=here("data", "clean_data", "tef_walleye.csv"), mix)
```

walleye: plot isospace
```{r walleye: plot isospace}
#Make isospace plot
#plot_data
library(rlang)

iso_plot_walleye<-plot_data(filename=" walleye_isospace_plot", plot_save_pdf=FALSE,
          plot_save_png=FALSE, mix,source,discr,return_obj = TRUE)


#ggplot(iso_plot_walleye)


```

walleye: Plot prior
```{r walleye: Plot prior}
# Informative prior:

# American shad: 0.1%
# mixed non-Salmonidae fish: 67.3%
# mixed subyearling Salmonidae: 6.75%
# mixed yearling Salmonidae: 6.75%




# Generate alpha hyperparameters scaling sum(alpha)=n.sources

percent.weight.alpha <- c(0.1,67.3,6.75,6.75) 

percent.weight.alpha <- percent.weight.alpha*length(percent.weight.alpha)/sum(percent.weight.alpha)

plot_prior(percent.weight.alpha, source)
```

walleye: run model
```{r walleye: run model}
library(stringi)
library(MCMCpack)
model_filename <- "MixSIAR_model.txt"
resid_err <- TRUE
process_err <-TRUE
write_JAGS_model(model_filename, resid_err, process_err, mix, source)

#run_model
jags.1 <- run_model(run="extreme",mix,source,discr,model_filename,
                    alpha.prior = percent.weight.alpha,resid_err,process_err)


 
#Process output
 #output_JAGS
output_JAGS(jags.1, mix, source)

# save model so that it can be called up again without having to be run again
save.image(file='walleye.model.with.size.RData')
```


NPM: load data in
```{r NPM: load data in}

library(MixSIAR)

#load_mix_data
#mix <- load_mix_data(filename="npm_mix_mixsiar.csv",
#iso_names=c("d15N","d13C"), factors="size_class",fac_random=FALSE,
#fac_nested=FALSE, cont_effects=NULL)

#load_mix_data if no size class factors included.
mix <- load_mix_data(filename=here("data", "clean_data", "npm_mix_mixsiar.csv"),
iso_names=c("d15N","d13C"), factors=NULL,fac_random=NULL,
fac_nested=NULL, cont_effects="length_mm")

#load_source_data
source <- load_source_data(filename=here("data", "clean_data", "prey_data_npm_avg.csv"),
source_factors=NULL, conc_dep=FALSE, data_type="means", mix)

#Load discrimination data
discr <- load_discr_data(filename=here("data", "clean_data", "tef_npm.csv"), mix)
```

NPM: plot isospace
```{r NPM: plot isospace}
#Make isospace plot
#plot_data
npn_iso<-plot_data(filename="NPM_isospace_plot", plot_save_pdf=FALSE,
          plot_save_png=FALSE, mix,source,discr,return_obj = TRUE)
```

NPM: Plot prior
```{r NPM: Plot prior}
# Informative prior:

# American shad: 0.3%
# mixed non-Salmonid: 20.3%
# subyearling Salmonid: 33.35%
# yearling Salmonid: 33.35%


# Generate alpha hyperparameters scaling sum(alpha)=n.sources

percent.weight.alpha <- c(0.3,20.3,33.35,33.35) 

percent.weight.alpha <- percent.weight.alpha*length(percent.weight.alpha)/sum(percent.weight.alpha)

plot_prior(percent.weight.alpha, source)
```

NPM: run model
```{r NPM: run model}
library(stringi)
library(MCMCpack)

model_filename <- "MixSIAR_model.txt"
resid_err <- TRUE
process_err <- TRUE
write_JAGS_model(model_filename, resid_err, process_err, mix, source)

#run_model
jags.1 <- run_model(run="extreme",mix,source,discr,model_filename,
                    alpha.prior = percent.weight.alpha,resid_err,process_err)
#Process output
 #output_JAGS
output_JAGS(jags.1, mix, source)

# save model so that it can be called up again without having to be run again
save.image(file='npm.model.with.size.RData')
```



walleye plot_continuous_var source code to modify total length plot
```{r walleye plot_continuous_var source code to modify  total length plot}
#' Plot proportions by a continuous covariate
#'
#' \code{plot_continuous_var} creates a plot of how the mixture proportions
#' change according to a continuous covariate, as well as plots of the mixture
#' proportions for the individuals with minimum, median, and maximum covariate
#' values. Called by \code{\link{output_JAGS}} if any continuous effects are in
#' the model.
#'
#' MixSIAR fits a continuous covariate as a linear regression in ILR/transform-space.
#' Two terms are fit for the proportion of each source: an intercept and a slope.
#' The plotted line uses the posterior median estimates of the intercept and slope, and
#' the lines are curved because of the ILR-transform back into proportion-space. The 
#' 95\% credible intervals are shaded.
#' 
#' If the model contains both a continuous AND a categorical (factor) covariate, MixSIAR
#' fits a different intercept term for each factor level and all levels share the
#' same slope term.
#'
#' @param jags.1 output from \code{\link{run_model}}
#' @param mix output from \code{\link{load_mix_data}}
#' @param source output from \code{\link{load_source_data}}
#' @param output_options list containing options for plots and saving, passed from \code{\link{output_JAGS}}
#' @param alphaCI alpha level for credible intervals (default = 0.05, 95\% CI)
#' @param exclude_sources_below don't plot sources with median proportion below this level for entire range of continuous effect variable (default = 0.1)
#'
#' @seealso Francis et al. 2011
#' @export
plot_continuous_var <- function(jags.1, mix, source, output_options, alphaCI=0.05, exclude_sources_below=0.1){
# added only to pass R CMD check
# ilr.global <- x <- p.global <- p.ind <- sources <- ..scaled.. <- NULL
R2jags::attach.jags(jags.1)
n.sources <- source$n.sources
source_names <- source$source_names

output_options=list(
                                                  summary_save = TRUE,                 # Save the summary statistics as a txt file?
                                                  summary_name = "summary_statistics",    # If yes, specify the base file name (.txt will be appended later)
                                                  sup_post = TRUE,                       # Suppress posterior density plot output in R?
                                                  plot_post_save_pdf = TRUE,              # Save posterior density plots as pdfs?
                                                  plot_post_name = "posterior_density",   # If yes, specify the base file name(s) (.pdf/.png will be appended later)
                                                  sup_pairs = FALSE,                      # Suppress pairs plot output in R?
                                                  plot_pairs_save_pdf = TRUE,             # Save pairs plot as pdf?
                                                  plot_pairs_name = "pairs_plot",         # If yes, specify the base file name (.pdf/.png will be appended later)
                                                  sup_xy = TRUE,                         # Suppress xy/trace plot output in R?
                                                  plot_xy_save_pdf = FALSE,                # Save xy/trace plot as pdf?
                                                  plot_xy_name = "xy_plot",               # If yes, specify the base file name (.pdf/.png will be appended later)
                                                  gelman = TRUE,                          # Calculate Gelman-Rubin diagnostic test?
                                                  heidel = FALSE,                          # Calculate Heidelberg-Welch diagnostic test?
                                                  geweke = TRUE,                          # Calculate Geweke diagnostic test?
                                                  diag_save = TRUE,                       # Save the diagnostics as a txt file?
                                                  diag_name = "diagnostics",              # If yes, specify the base file name (.txt will be appended later)
                                                  indiv_effect = FALSE,                   # Is Individual a random effect in the model? (already specified)
                                                  plot_post_save_png = FALSE,             # Save posterior density plots as pngs?
                                                  plot_pairs_save_png = FALSE,            # Save pairs plot as png?
                                                  plot_xy_save_png = FALSE,
                                                  diag_save_ggmcmc = FALSE)


for(ce in 1:mix$n.ce){
  if(mix$n.effects == 1){ # if there is a FE/RE in addition to continuous effect
    for(f1 in 1:mix$FAC[[1]]$levels){
      fac.lab <- mix$FAC[[1]]$labels[f1]
      label <- mix$cont_effects[ce]
      cont <- mix$CE[[ce]]
      ilr.cont <- get(paste("ilr.cont",ce,sep=""))

      n.plot = 200
      chain.len = dim(p.global)[1]
      Cont1.plot <- seq(from=round(min(cont),1), to=round(max(cont),1), length.out=n.plot)
      ilr.plot <- array(NA,dim=c(n.plot, n.sources-1, chain.len))
      for(src in 1:n.sources-1){
        for(i in 1:n.plot){
         ilr.plot[i,src,] <- ilr.global[,src] + ilr.cont[,src]*Cont1.plot[i] + ilr.fac1[,f1,src]
        }
      }

      # Transform every draw from ILR-space to p-space
      e <- matrix(rep(0,n.sources*(n.sources-1)),nrow=n.sources,ncol=(n.sources-1))
      for(i in 1:(n.sources-1)){
         e[,i] <- exp(c(rep(sqrt(1/(i*(i+1))),i),-sqrt(i/(i+1)),rep(0,n.sources-i-1)))
         e[,i] <- e[,i]/sum(e[,i])
      }
      # dummy variables for inverse ILR calculation
      cross <- array(data=NA,dim=c(n.plot, chain.len, n.sources, n.sources-1))  
      tmp <- array(data=NA,dim=c(n.plot, chain.len, n.sources))  
      p.plot <- array(data=NA,dim=c(n.plot, chain.len, n.sources))  
      for(i in 1:n.plot){
        for(d in 1:chain.len){
          for(j in 1:(n.sources-1)){
            cross[i,d,,j] <- (e[,j]^ilr.plot[i,j,d])/sum(e[,j]^ilr.plot[i,j,d]);
          }
          for(src in 1:n.sources){
            tmp[i,d,src] <- prod(cross[i,d,src,]);
          }
          for(src in 1:n.sources){
            p.plot[i,d,src] <- tmp[i,d,src]/sum(tmp[i,d,]);
          }
        }
      }
      # now take quantiles, after ILR transform of every draw
      get_high <- function(x){return(quantile(x, 1-alphaCI/2))}
      get_low <- function(x){return(quantile(x, alphaCI/2))}
      p.low <- apply(p.plot, c(1,3), get_low)
      p.high <- apply(p.plot, c(1,3), get_high)
      p.median <- apply(p.plot, c(1,3), median)
      colnames(p.median) <- source_names
      
      Cont1.plot <- Cont1.plot*mix$CE_scale + mix$CE_center # transform Cont1.plot (x-axis) back to the original scale
      df <- data.frame(reshape2::melt(p.median)[,2:3], rep(Cont1.plot,n.sources), reshape2::melt(p.low)[,3], reshape2::melt(p.high)[,3])
      colnames(df) <- c("source","median","x","low","high")
      df$source <- factor(df$source, levels=source_names)
      
      # remove sources from plot with very low proportions
      rm.srcs <- apply(p.median, 2, function(x) all(x < exclude_sources_below))
      df <- subset(df, source %in% source_names[!rm.srcs])

      # medians <- data.frame(cont,apply(p.ind,c(2,3),median))
      # colnames(medians) <- c("cont",source_names)
      # medians <- melt(medians,id="cont")

      # Plot of Diet vs. Cont effect
      # Page 370 in Francis et al (2011)
      dev.new()
      
             df$sources <- factor(df$sources, 
                                  levels = c("mixed non-Salmonidae fish",
                                             "mixed subyearling Salmonidae",
                                             "mixed yearling Salmonidae",
                                             "Percopsidae"))


      
      # Save the plot to file
      if(output_options[[4]]){ # svalue(plot_post_save_pdf)
        mypath <- file.path(paste(getwd(),"/",output_options[[5]],"_",fac.lab,"_",label,"_cont.pdf",sep=""))  # svalue(plot_post_name)
        dev.copy2pdf(file=mypath)
      }
      if(output_options[[18]]){ # svalue(plot_post_save_png)
        mypath <- file.path(paste(getwd(),"/",output_options[[5]],"_",fac.lab,"_",label,"_cont.png",sep=""))  # svalue(plot_post_name)
        dev.copy(png,mypath)
      }
      
      # Posterior plot for min(Cont1), median(Cont1), and max(Cont1)
      # Page 370 in Francis et al (2011)
      n.draws <- length(p.global[,1])
      # min(Cont1)
      dev.new()
      df <- data.frame(sources=rep(NA,n.draws*n.sources), x=rep(NA,n.draws*n.sources))  # create empty data frame
      f1.cont <- cont[mix$FAC[[1]]$values == f1,1]
      min_ind <- which(cont==min(f1.cont) & mix$FAC[[1]]$values == f1)[1]   # find the index of min(Cont1)
      for(src in 1:n.sources){
        df$x[seq(1+n.draws*(src-1),src*n.draws)] <- as.matrix(p.ind[,min_ind,src]) # fill in the p.ind values
        df$sources[seq(1+n.draws*(src-1),src*n.draws)] <- rep(source_names[src],n.draws)  # fill in the source names
      }
      cont.lab = format(cont[min_ind]*mix$CE_scale + mix$CE_center, digits=3)

      
      # median(Cont1)
      dev.new()
      df <- data.frame(sources=rep(NA,n.draws*n.sources), x=rep(NA,n.draws*n.sources))  # create empty data frame
      is.odd <- length(f1.cont) %% 2                # mod 2 division - odd length will return 1, even length returns 0
      if(is.odd==1) {med_ind <- which(cont==median(f1.cont) & mix$FAC[[1]]$values == f1)}   # find the index of median(Cont1)
      if(is.odd==0){ # If Cont.1 is even, this finds the index of the value just below the median. Here, median(Cont.1) has no corresponding index.
        if(sum(cont==median(f1.cont)) < length(f1.cont)/2) med_ind <- which(cont==max(sort(f1.cont[which(f1.cont<median(f1.cont))])) & mix$FAC[[1]]$values == f1) else {
          med_ind <- which(cont==median(f1.cont))[1]
        }
      }   
      for(src in 1:n.sources){
        df$x[seq(1+n.draws*(src-1),src*n.draws)] <- as.matrix(p.ind[,med_ind,src]) # fill in the p.ind values
        df$sources[seq(1+n.draws*(src-1),src*n.draws)] <- rep(source_names[src],n.draws)  # fill in the source names
      }
      cont.lab = format(cont[med_ind]*mix$CE_scale + mix$CE_center, digits=3)

      
      # max(Cont1)
      dev.new()
      df <- data.frame(sources=rep(NA,n.draws*n.sources), x=rep(NA,n.draws*n.sources))  # create empty data frame
      max_ind <- which(cont==max(f1.cont) & mix$FAC[[1]]$values == f1)[1]   # find the index of max(Cont1)
      for(src in 1:n.sources){
        df$x[seq(1+n.draws*(src-1),src*n.draws)] <- as.matrix(p.ind[,max_ind,src])    # fill in the p.ind values
        df$sources[seq(1+n.draws*(src-1),src*n.draws)] <- rep(source_names[src],n.draws)  # fill in the source names
      }
      cont.lab = format(cont[max_ind]*mix$CE_scale + mix$CE_center, digits=3)

    } # end loop over factor1 levels
  } # end if YES FE/RE

  if(mix$n.effects == 0){
    label <- mix$cont_effects[ce]
    cont <- mix$CE[[ce]]
    ilr.cont <- get(paste("ilr.cont",ce,sep=""))

    n.plot = 200
    chain.len = dim(p.global)[1]
    Cont1.plot <- seq(from=round(min(cont),1), to=round(max(cont),1), length.out=n.plot)
    ilr.plot <- array(NA,dim=c(n.plot, n.sources-1, chain.len))
    for(src in 1:n.sources-1){
      for(i in 1:n.plot){
       ilr.plot[i,src,] <- ilr.global[,src] + ilr.cont[,src]*Cont1.plot[i]
      }
    }

    # Transform regression lines from ILR-space to p-space
    e <- matrix(rep(0,n.sources*(n.sources-1)),nrow=n.sources,ncol=(n.sources-1))
    for(i in 1:(n.sources-1)){
       e[,i] <- exp(c(rep(sqrt(1/(i*(i+1))),i),-sqrt(i/(i+1)),rep(0,n.sources-i-1)))
       e[,i] <- e[,i]/sum(e[,i])
    }
    # dummy variables for inverse ILR calculation
    cross <- array(data=NA,dim=c(n.plot, chain.len, n.sources, n.sources-1))  
    tmp <- array(data=NA,dim=c(n.plot, chain.len, n.sources))  
    p.plot <- array(data=NA,dim=c(n.plot, chain.len, n.sources))  
    for(i in 1:n.plot){
      for(d in 1:chain.len){
        for(j in 1:(n.sources-1)){
          cross[i,d,,j] <- (e[,j]^ilr.plot[i,j,d])/sum(e[,j]^ilr.plot[i,j,d]);
        }
        for(src in 1:n.sources){
          tmp[i,d,src] <- prod(cross[i,d,src,]);
        }
        for(src in 1:n.sources){
          p.plot[i,d,src] <- tmp[i,d,src]/sum(tmp[i,d,]);
        }
      }
    }
    # now take quantiles, after ILR transform of every draw
    get_high <- function(x){return(quantile(x, 1-alphaCI/2))}
    get_low <- function(x){return(quantile(x, alphaCI/2))}
    p.low <- apply(p.plot, c(1,3), get_low)
    p.high <- apply(p.plot, c(1,3), get_high)
    p.median <- apply(p.plot, c(1,3), median)
    colnames(p.median) <- source_names
    
    Cont1.plot <- Cont1.plot*mix$CE_scale + mix$CE_center # transform Cont1.plot (x-axis) back to the original scale
    df <- data.frame(reshape2::melt(p.median)[,2:3], rep(Cont1.plot,n.sources), reshape2::melt(p.low)[,3], reshape2::melt(p.high)[,3])
    colnames(df) <- c("source","median","x","low","high")
    df$source <- factor(df$source, levels=source_names)
    
    # remove sources from plot with very low proportions
    rm.srcs <- apply(p.median, 2, function(x) all(x < exclude_sources_below))
    df <- subset(df, source %in% source_names[!rm.srcs])

    # Plot of Diet vs. Cont effect
    # Page 370 in Francis et al (2011)
    dev.new()
          # print(ggplot2::ggplot(data=df,ggplot2::aes(x=x,y=median)) +
          #     ggplot2::geom_line(ggplot2::aes(x=x, y=median,group=source,colour=source),size=1.5) +
          #     ggplot2::geom_ribbon(ggplot2::aes(ymin=low, ymax=high, group=source, fill=source), alpha=0.35) +
          #     ggplot2::scale_color_brewer(palette = "Set1",aesthetics = c("colour", "fill")) +
          #     ggplot2::labs(title = "walleye") +
          #     ggplot2::ylab("Diet proportion") +
          #     ggplot2::xlab("Total length (mm)") +
          #     ggplot2::scale_y_continuous(expand = c(0, 0), limits=c(0,1)) +
          #     ggplot2::scale_x_continuous(expand = c(0, 0),limits = c(240,700),breaks = c(300,400,500,600)) +
          #     ggplot2::theme_bw() +
          #     ggplot2::theme(panel.border = ggplot2::element_blank(), panel.grid.major = ggplot2::element_blank(), 
          #       panel.grid.minor = ggplot2::element_blank(), panel.background = ggplot2::element_blank(), 
          #       axis.line = ggplot2::element_line(colour = "black"), axis.title=ggplot2::element_text(size=16), 
          #       axis.text=ggplot2::element_text(size=14), legend.text=ggplot2::element_text(size=14), legend.position="bottom", 
          #       legend.justification=c(1,1), legend.title=ggplot2::element_blank()))
          # 
    
          
           print(ggplot2::ggplot(data=df,ggplot2::aes(x=x,y=median)) +
              ggplot2::geom_line(ggplot2::aes(x=x, y=median,group=source,colour=source),size=1.5) +
              ggplot2::scale_color_brewer(palette = "Set1",aesthetics = "colour") +
              ggplot2::labs(title = "walleye") +
              ggplot2::ylab("Diet proportion") +
              ggplot2::xlab("Total length (mm)") +
              ggplot2::scale_y_continuous(expand = c(0, 0), limits=c(0,1)) +
              ggplot2::scale_x_continuous(expand = c(0, 0),limits = c(240,700),breaks = c(300,400,500,600)) +
              ggplot2::theme_bw() +
              ggplot2::theme(panel.border = ggplot2::element_blank(), panel.grid.major = ggplot2::element_blank(), 
                panel.grid.minor = ggplot2::element_blank(), panel.background = ggplot2::element_blank(), 
                axis.line = ggplot2::element_line(colour = "black"), axis.title=ggplot2::element_text(size=16), 
                axis.text=ggplot2::element_text(size=14), legend.text=ggplot2::element_text(size=14), legend.position="bottom", 
                legend.justification=c(1,1), legend.title=ggplot2::element_blank()))
                   
                
    # Save the plot to file
    if(output_options[[4]]){ # svalue(plot_post_save_pdf)
      mypath <- file.path(paste(getwd(),"/",output_options[[5]],"_",label,".pdf",sep=""))  # svalue(plot_post_name)
      dev.copy2pdf(file=mypath)
    }
    if(output_options[[18]]){ # svalue(plot_post_save_png)
      mypath <- file.path(paste(getwd(),"/",output_options[[5]],"_",label,".png",sep=""))  # svalue(plot_post_name)
      dev.copy(png,mypath)
    }
    
    # Posterior plot for min(Cont1), median(Cont1), and max(Cont1)
    # Page 370 in Francis et al (2011)
    n.draws <- length(p.global[,1])
    # min(Cont1)
    dev.new()
    df <- data.frame(sources=rep(NA,n.draws*n.sources), x=rep(NA,n.draws*n.sources))  # create empty data frame
    min_ind <- which(cont==min(cont))[1]   # find the index of min(Cont1)
    for(src in 1:n.sources){
      df$x[seq(1+n.draws*(src-1),src*n.draws)] <- as.matrix(p.ind[,min_ind,src]) # fill in the p.ind values
      df$sources[seq(1+n.draws*(src-1),src*n.draws)] <- rep(source_names[src],n.draws)  # fill in the source names
    }

    
    # median(Cont1)
    dev.new()
    df <- data.frame(sources=rep(NA,n.draws*n.sources), x=rep(NA,n.draws*n.sources))  # create empty data frame
    is.odd <- length(cont) %% 2                # mod 2 division - odd length will return 1, even length returns 0
    if(is.odd==1) {med_ind <- which(cont==median(cont))}   # find the index of median(Cont1)
    if(is.odd==0){ # If Cont.1 is even, this finds the index of the value just below the median. Here, median(Cont.1) has no corresponding index.
      if(sum(cont==median(cont)) < length(cont)/2) med_ind <- which(cont==max(sort(cont[which(cont<median(cont))]))) else {
        med_ind <- which(cont==median(cont))[1]
      }
    }   
    for(src in 1:n.sources){
      df$x[seq(1+n.draws*(src-1),src*n.draws)] <- as.matrix(p.ind[,med_ind,src]) # fill in the p.ind values
      df$sources[seq(1+n.draws*(src-1),src*n.draws)] <- rep(source_names[src],n.draws)  # fill in the source names
    }

    
    # max(Cont1)
    dev.new()
    df <- data.frame(sources=rep(NA,n.draws*n.sources), x=rep(NA,n.draws*n.sources))  # create empty data frame
    max_ind <- which(cont==max(cont))[1]   # find the index of max(Cont1)
    for(src in 1:n.sources){
      df$x[seq(1+n.draws*(src-1),src*n.draws)] <- as.matrix(p.ind[,max_ind,src])    # fill in the p.ind values
      df$sources[seq(1+n.draws*(src-1),src*n.draws)] <- rep(source_names[src],n.draws)  # fill in the source names
    }

  } # end if NO FE/RE
} # end loop over ce
} #end plot_continuous_var function


 plot_continuous_var(jags.1,mix,source,output_options,exclude_sources_below = 0.3)
```





npm plot_continuous_var source code to modify total length plot
```{r npm plot_continuous_var source code to modify  total length plot}
#' Plot proportions by a continuous covariate
#'
#' \code{plot_continuous_var} creates a plot of how the mixture proportions
#' change according to a continuous covariate, as well as plots of the mixture
#' proportions for the individuals with minimum, median, and maximum covariate
#' values. Called by \code{\link{output_JAGS}} if any continuous effects are in
#' the model.
#'
#' MixSIAR fits a continuous covariate as a linear regression in ILR/transform-space.
#' Two terms are fit for the proportion of each source: an intercept and a slope.
#' The plotted line uses the posterior median estimates of the intercept and slope, and
#' the lines are curved because of the ILR-transform back into proportion-space. The 
#' 95\% credible intervals are shaded.
#' 
#' If the model contains both a continuous AND a categorical (factor) covariate, MixSIAR
#' fits a different intercept term for each factor level and all levels share the
#' same slope term.
#'
#' @param jags.1 output from \code{\link{run_model}}
#' @param mix output from \code{\link{load_mix_data}}
#' @param source output from \code{\link{load_source_data}}
#' @param output_options list containing options for plots and saving, passed from \code{\link{output_JAGS}}
#' @param alphaCI alpha level for credible intervals (default = 0.05, 95\% CI)
#' @param exclude_sources_below don't plot sources with median proportion below this level for entire range of continuous effect variable (default = 0.1)
#'
#' @seealso Francis et al. 2011
#' @export
plot_continuous_var <- function(jags.1, mix, source, output_options, alphaCI=0.05, exclude_sources_below=0.1){
# added only to pass R CMD check
# ilr.global <- x <- p.global <- p.ind <- sources <- ..scaled.. <- NULL
R2jags::attach.jags(jags.1)
n.sources <- source$n.sources
source_names <- source$source_names

output_options=list(
                                                  summary_save = TRUE,                 # Save the summary statistics as a txt file?
                                                  summary_name = "summary_statistics",    # If yes, specify the base file name (.txt will be appended later)
                                                  sup_post = TRUE,                       # Suppress posterior density plot output in R?
                                                  plot_post_save_pdf = TRUE,              # Save posterior density plots as pdfs?
                                                  plot_post_name = "posterior_density",   # If yes, specify the base file name(s) (.pdf/.png will be appended later)
                                                  sup_pairs = FALSE,                      # Suppress pairs plot output in R?
                                                  plot_pairs_save_pdf = TRUE,             # Save pairs plot as pdf?
                                                  plot_pairs_name = "pairs_plot",         # If yes, specify the base file name (.pdf/.png will be appended later)
                                                  sup_xy = TRUE,                         # Suppress xy/trace plot output in R?
                                                  plot_xy_save_pdf = FALSE,                # Save xy/trace plot as pdf?
                                                  plot_xy_name = "xy_plot",               # If yes, specify the base file name (.pdf/.png will be appended later)
                                                  gelman = TRUE,                          # Calculate Gelman-Rubin diagnostic test?
                                                  heidel = FALSE,                          # Calculate Heidelberg-Welch diagnostic test?
                                                  geweke = TRUE,                          # Calculate Geweke diagnostic test?
                                                  diag_save = TRUE,                       # Save the diagnostics as a txt file?
                                                  diag_name = "diagnostics",              # If yes, specify the base file name (.txt will be appended later)
                                                  indiv_effect = FALSE,                   # Is Individual a random effect in the model? (already specified)
                                                  plot_post_save_png = FALSE,             # Save posterior density plots as pngs?
                                                  plot_pairs_save_png = FALSE,            # Save pairs plot as png?
                                                  plot_xy_save_png = FALSE,
                                                  diag_save_ggmcmc = FALSE)


for(ce in 1:mix$n.ce){
  if(mix$n.effects == 1){ # if there is a FE/RE in addition to continuous effect
    for(f1 in 1:mix$FAC[[1]]$levels){
      fac.lab <- mix$FAC[[1]]$labels[f1]
      label <- mix$cont_effects[ce]
      cont <- mix$CE[[ce]]
      ilr.cont <- get(paste("ilr.cont",ce,sep=""))

      n.plot = 200
      chain.len = dim(p.global)[1]
      Cont1.plot <- seq(from=round(min(cont),1), to=round(max(cont),1), length.out=n.plot)
      ilr.plot <- array(NA,dim=c(n.plot, n.sources-1, chain.len))
      for(src in 1:n.sources-1){
        for(i in 1:n.plot){
         ilr.plot[i,src,] <- ilr.global[,src] + ilr.cont[,src]*Cont1.plot[i] + ilr.fac1[,f1,src]
        }
      }

      # Transform every draw from ILR-space to p-space
      e <- matrix(rep(0,n.sources*(n.sources-1)),nrow=n.sources,ncol=(n.sources-1))
      for(i in 1:(n.sources-1)){
         e[,i] <- exp(c(rep(sqrt(1/(i*(i+1))),i),-sqrt(i/(i+1)),rep(0,n.sources-i-1)))
         e[,i] <- e[,i]/sum(e[,i])
      }
      # dummy variables for inverse ILR calculation
      cross <- array(data=NA,dim=c(n.plot, chain.len, n.sources, n.sources-1))  
      tmp <- array(data=NA,dim=c(n.plot, chain.len, n.sources))  
      p.plot <- array(data=NA,dim=c(n.plot, chain.len, n.sources))  
      for(i in 1:n.plot){
        for(d in 1:chain.len){
          for(j in 1:(n.sources-1)){
            cross[i,d,,j] <- (e[,j]^ilr.plot[i,j,d])/sum(e[,j]^ilr.plot[i,j,d]);
          }
          for(src in 1:n.sources){
            tmp[i,d,src] <- prod(cross[i,d,src,]);
          }
          for(src in 1:n.sources){
            p.plot[i,d,src] <- tmp[i,d,src]/sum(tmp[i,d,]);
          }
        }
      }
      # now take quantiles, after ILR transform of every draw
      get_high <- function(x){return(quantile(x, 1-alphaCI/2))}
      get_low <- function(x){return(quantile(x, alphaCI/2))}
      p.low <- apply(p.plot, c(1,3), get_low)
      p.high <- apply(p.plot, c(1,3), get_high)
      p.median <- apply(p.plot, c(1,3), median)
      colnames(p.median) <- source_names
      
      Cont1.plot <- Cont1.plot*mix$CE_scale + mix$CE_center # transform Cont1.plot (x-axis) back to the original scale
      df <- data.frame(reshape2::melt(p.median)[,2:3], rep(Cont1.plot,n.sources), reshape2::melt(p.low)[,3], reshape2::melt(p.high)[,3])
      colnames(df) <- c("source","median","x","low","high")
      df$source <- factor(df$source, levels=source_names)
      
      # remove sources from plot with very low proportions
      rm.srcs <- apply(p.median, 2, function(x) all(x < exclude_sources_below))
      df <- subset(df, source %in% source_names[!rm.srcs])

      # medians <- data.frame(cont,apply(p.ind,c(2,3),median))
      # colnames(medians) <- c("cont",source_names)
      # medians <- melt(medians,id="cont")

      # Plot of Diet vs. Cont effect
      # Page 370 in Francis et al (2011)
      dev.new()
      
       df$sources <- factor(df$sources, 
                                  levels = c("American Shad",
                                             "mixed non-Salmonidae",
                                             "mixed subyearling Salmonidae",
                                             "mixed yearling Salmonidae"))
            
 

      
      # Save the plot to file
      if(output_options[[4]]){ # svalue(plot_post_save_pdf)
        mypath <- file.path(paste(getwd(),"/",output_options[[5]],"_",fac.lab,"_",label,"_cont.pdf",sep=""))  # svalue(plot_post_name)
        dev.copy2pdf(file=mypath)
      }
      if(output_options[[18]]){ # svalue(plot_post_save_png)
        mypath <- file.path(paste(getwd(),"/",output_options[[5]],"_",fac.lab,"_",label,"_cont.png",sep=""))  # svalue(plot_post_name)
        dev.copy(png,mypath)
      }
      
      # Posterior plot for min(Cont1), median(Cont1), and max(Cont1)
      # Page 370 in Francis et al (2011)
      n.draws <- length(p.global[,1])
      # min(Cont1)
      dev.new()
      df <- data.frame(sources=rep(NA,n.draws*n.sources), x=rep(NA,n.draws*n.sources))  # create empty data frame
      f1.cont <- cont[mix$FAC[[1]]$values == f1,1]
      min_ind <- which(cont==min(f1.cont) & mix$FAC[[1]]$values == f1)[1]   # find the index of min(Cont1)
      for(src in 1:n.sources){
        df$x[seq(1+n.draws*(src-1),src*n.draws)] <- as.matrix(p.ind[,min_ind,src]) # fill in the p.ind values
        df$sources[seq(1+n.draws*(src-1),src*n.draws)] <- rep(source_names[src],n.draws)  # fill in the source names
      }
      cont.lab = format(cont[min_ind]*mix$CE_scale + mix$CE_center, digits=3)

      
      # median(Cont1)
      dev.new()
      df <- data.frame(sources=rep(NA,n.draws*n.sources), x=rep(NA,n.draws*n.sources))  # create empty data frame
      is.odd <- length(f1.cont) %% 2                # mod 2 division - odd length will return 1, even length returns 0
      if(is.odd==1) {med_ind <- which(cont==median(f1.cont) & mix$FAC[[1]]$values == f1)}   # find the index of median(Cont1)
      if(is.odd==0){ # If Cont.1 is even, this finds the index of the value just below the median. Here, median(Cont.1) has no corresponding index.
        if(sum(cont==median(f1.cont)) < length(f1.cont)/2) med_ind <- which(cont==max(sort(f1.cont[which(f1.cont<median(f1.cont))])) & mix$FAC[[1]]$values == f1) else {
          med_ind <- which(cont==median(f1.cont))[1]
        }
      }   
      for(src in 1:n.sources){
        df$x[seq(1+n.draws*(src-1),src*n.draws)] <- as.matrix(p.ind[,med_ind,src]) # fill in the p.ind values
        df$sources[seq(1+n.draws*(src-1),src*n.draws)] <- rep(source_names[src],n.draws)  # fill in the source names
      }
      cont.lab = format(cont[med_ind]*mix$CE_scale + mix$CE_center, digits=3)

      
      # max(Cont1)
      dev.new()
      df <- data.frame(sources=rep(NA,n.draws*n.sources), x=rep(NA,n.draws*n.sources))  # create empty data frame
      max_ind <- which(cont==max(f1.cont) & mix$FAC[[1]]$values == f1)[1]   # find the index of max(Cont1)
      for(src in 1:n.sources){
        df$x[seq(1+n.draws*(src-1),src*n.draws)] <- as.matrix(p.ind[,max_ind,src])    # fill in the p.ind values
        df$sources[seq(1+n.draws*(src-1),src*n.draws)] <- rep(source_names[src],n.draws)  # fill in the source names
      }
      cont.lab = format(cont[max_ind]*mix$CE_scale + mix$CE_center, digits=3)

    } # end loop over factor1 levels
  } # end if YES FE/RE

  if(mix$n.effects == 0){
    label <- mix$cont_effects[ce]
    cont <- mix$CE[[ce]]
    ilr.cont <- get(paste("ilr.cont",ce,sep=""))

    n.plot = 200
    chain.len = dim(p.global)[1]
    Cont1.plot <- seq(from=round(min(cont),1), to=round(max(cont),1), length.out=n.plot)
    ilr.plot <- array(NA,dim=c(n.plot, n.sources-1, chain.len))
    for(src in 1:n.sources-1){
      for(i in 1:n.plot){
       ilr.plot[i,src,] <- ilr.global[,src] + ilr.cont[,src]*Cont1.plot[i]
      }
    }

    # Transform regression lines from ILR-space to p-space
    e <- matrix(rep(0,n.sources*(n.sources-1)),nrow=n.sources,ncol=(n.sources-1))
    for(i in 1:(n.sources-1)){
       e[,i] <- exp(c(rep(sqrt(1/(i*(i+1))),i),-sqrt(i/(i+1)),rep(0,n.sources-i-1)))
       e[,i] <- e[,i]/sum(e[,i])
    }
    # dummy variables for inverse ILR calculation
    cross <- array(data=NA,dim=c(n.plot, chain.len, n.sources, n.sources-1))  
    tmp <- array(data=NA,dim=c(n.plot, chain.len, n.sources))  
    p.plot <- array(data=NA,dim=c(n.plot, chain.len, n.sources))  
    for(i in 1:n.plot){
      for(d in 1:chain.len){
        for(j in 1:(n.sources-1)){
          cross[i,d,,j] <- (e[,j]^ilr.plot[i,j,d])/sum(e[,j]^ilr.plot[i,j,d]);
        }
        for(src in 1:n.sources){
          tmp[i,d,src] <- prod(cross[i,d,src,]);
        }
        for(src in 1:n.sources){
          p.plot[i,d,src] <- tmp[i,d,src]/sum(tmp[i,d,]);
        }
      }
    }
    # now take quantiles, after ILR transform of every draw
    get_high <- function(x){return(quantile(x, 1-alphaCI/2))}
    get_low <- function(x){return(quantile(x, alphaCI/2))}
    p.low <- apply(p.plot, c(1,3), get_low)
    p.high <- apply(p.plot, c(1,3), get_high)
    p.median <- apply(p.plot, c(1,3), median)
    colnames(p.median) <- source_names
    
    Cont1.plot <- Cont1.plot*mix$CE_scale + mix$CE_center # transform Cont1.plot (x-axis) back to the original scale
    df <- data.frame(reshape2::melt(p.median)[,2:3], rep(Cont1.plot,n.sources), reshape2::melt(p.low)[,3], reshape2::melt(p.high)[,3])
    colnames(df) <- c("source","median","x","low","high")
    df$source <- factor(df$source, levels=source_names)
    
    # remove sources from plot with very low proportions
#    rm.srcs <- apply(p.median, 2, function(x) all(x < exclude_sources_below))
#    df <- subset(df, source %in% source_names[!rm.srcs])

    # Plot of Diet vs. Cont effect
    # Page 370 in Francis et al (2011)
    dev.new()
          print(ggplot2::ggplot(data=df,ggplot2::aes(x=x,y=median)) +
              ggplot2::geom_line(ggplot2::aes(x=x, y=median,group=source,colour=source),size=1.5) +
              #ggplot2::geom_ribbon(ggplot2::aes(ymin=low, ymax=high, group=source, fill=source), alpha=0.2) +
              ggplot2::scale_color_brewer(palette = "Set1",aesthetics = c("colour", "fill")) +
              ggplot2::labs(title = "Northern Pikeminnow") +
              ggplot2::ylab("Diet proportion") +
              ggplot2::xlab("Total length (mm)") +
              ggplot2::scale_y_continuous(expand = c(0, 0), limits=c(0,1)) +
              ggplot2::scale_x_continuous(expand = c(0, 0)) +
              ggplot2::theme_bw() +
              ggplot2::theme(panel.border = ggplot2::element_blank(), panel.grid.major = ggplot2::element_blank(),
                panel.grid.minor = ggplot2::element_blank(), panel.background = ggplot2::element_blank(),
                axis.line = ggplot2::element_line(colour = "black"), axis.title=ggplot2::element_text(size=16),
                axis.text=ggplot2::element_text(size=14), legend.text=ggplot2::element_text(size=12), legend.position="right",
                legend.justification=c(1,0.5), legend.title=ggplot2::element_blank()))

           # print(ggplot2::ggplot(data=df,ggplot2::aes(x=x,y=median)) +
           #    ggplot2::geom_line(ggplot2::aes(x=x, y=median,group=source,colour=source),size=1.5) +
           #    ggplot2::scale_color_brewer(palette = "Set1",aesthetics = "colour") +
           #    ggplot2::labs(title = "northern pikeminnow") +
           #    ggplot2::ylab("Diet proportion") +
           #    ggplot2::xlab("Total length (mm)") +
           #    ggplot2::scale_y_continuous(expand = c(0, 0), limits=c(0,1)) +
           #    ggplot2::scale_x_continuous(expand = c(0, 0)) +
           #    ggplot2::theme_bw() +
           #    ggplot2::theme(panel.border = ggplot2::element_blank(), panel.grid.major = ggplot2::element_blank(), 
           #      panel.grid.minor = ggplot2::element_blank(), panel.background = ggplot2::element_blank(), 
           #      axis.line = ggplot2::element_line(colour = "black"), axis.title=ggplot2::element_text(size=16), 
           #      axis.text=ggplot2::element_text(size=14), legend.text=ggplot2::element_text(size=12), legend.position="right", 
           #      legend.justification=c(1,1), legend.title=ggplot2::element_blank()))
            
          
          
          
          
                  
    # Save the plot to file
    if(output_options[[4]]){ # svalue(plot_post_save_pdf)
      mypath <- file.path(paste(getwd(),"/",output_options[[5]],"_",label,".pdf",sep=""))  # svalue(plot_post_name)
      dev.copy2pdf(file=mypath)
    }
    if(output_options[[18]]){ # svalue(plot_post_save_png)
      mypath <- file.path(paste(getwd(),"/",output_options[[5]],"_",label,".png",sep=""))  # svalue(plot_post_name)
      dev.copy(png,mypath)
    }
    
    # Posterior plot for min(Cont1), median(Cont1), and max(Cont1)
    # Page 370 in Francis et al (2011)
    n.draws <- length(p.global[,1])
    # min(Cont1)
    dev.new()
    df <- data.frame(sources=rep(NA,n.draws*n.sources), x=rep(NA,n.draws*n.sources))  # create empty data frame
    min_ind <- which(cont==min(cont))[1]   # find the index of min(Cont1)
    for(src in 1:n.sources){
      df$x[seq(1+n.draws*(src-1),src*n.draws)] <- as.matrix(p.ind[,min_ind,src]) # fill in the p.ind values
      df$sources[seq(1+n.draws*(src-1),src*n.draws)] <- rep(source_names[src],n.draws)  # fill in the source names
    }

    
    # median(Cont1)
    dev.new()
    df <- data.frame(sources=rep(NA,n.draws*n.sources), x=rep(NA,n.draws*n.sources))  # create empty data frame
    is.odd <- length(cont) %% 2                # mod 2 division - odd length will return 1, even length returns 0
    if(is.odd==1) {med_ind <- which(cont==median(cont))}   # find the index of median(Cont1)
    if(is.odd==0){ # If Cont.1 is even, this finds the index of the value just below the median. Here, median(Cont.1) has no corresponding index.
      if(sum(cont==median(cont)) < length(cont)/2) med_ind <- which(cont==max(sort(cont[which(cont<median(cont))]))) else {
        med_ind <- which(cont==median(cont))[1]
      }
    }   
    for(src in 1:n.sources){
      df$x[seq(1+n.draws*(src-1),src*n.draws)] <- as.matrix(p.ind[,med_ind,src]) # fill in the p.ind values
      df$sources[seq(1+n.draws*(src-1),src*n.draws)] <- rep(source_names[src],n.draws)  # fill in the source names
    }

    
    # max(Cont1)
    dev.new()
    df <- data.frame(sources=rep(NA,n.draws*n.sources), x=rep(NA,n.draws*n.sources))  # create empty data frame
    max_ind <- which(cont==max(cont))[1]   # find the index of max(Cont1)
    for(src in 1:n.sources){
      df$x[seq(1+n.draws*(src-1),src*n.draws)] <- as.matrix(p.ind[,max_ind,src])    # fill in the p.ind values
      df$sources[seq(1+n.draws*(src-1),src*n.draws)] <- rep(source_names[src],n.draws)  # fill in the source names
    }

  } # end if NO FE/RE
} # end loop over ce
} #end plot_continuous_var function


 plot_continuous_var(jags.1,mix,source,output_options,exclude_sources_below = 0.3)
```








